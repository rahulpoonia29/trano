// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries_api.sql

package db

import (
	"context"
	"database/sql"
)

const getLiveTrains = `-- name: GetLiveTrains :many
SELECT 
    t.train_name,
    t.train_type,
    tr.train_no,
    tr.last_known_snapped_lat_u6 AS lat_u6,
    tr.last_known_snapped_lng_u6 AS lng_u6,
    tr.last_bearing_deg AS bearing_deg,
    tr.current_status,
    tr.last_update_timestamp_iso
FROM train_runs tr
JOIN trains t ON tr.train_no = t.train_no
WHERE tr.has_arrived = 0
  AND tr.last_known_snapped_lat_u6 IS NOT NULL
  AND tr.last_known_snapped_lng_u6 IS NOT NULL
  -- Only recent updates (avoid stale data)
  AND datetime(tr.last_update_timestamp_iso) > datetime('now', '-15 minutes')
`

type GetLiveTrainsRow struct {
	TrainName              string         `json:"train_name"`
	TrainType              string         `json:"train_type"`
	TrainNo                int64          `json:"train_no"`
	LatU6                  sql.NullInt64  `json:"lat_u6"`
	LngU6                  sql.NullInt64  `json:"lng_u6"`
	BearingDeg             sql.NullInt64  `json:"bearing_deg"`
	CurrentStatus          interface{}    `json:"current_status"`
	LastUpdateTimestampIso sql.NullString `json:"last_update_timestamp_iso"`
}

// Returns data for active trains within viewport bounds
func (q *Queries) GetLiveTrains(ctx context.Context) ([]GetLiveTrainsRow, error) {
	rows, err := q.db.QueryContext(ctx, getLiveTrains)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLiveTrainsRow{}
	for rows.Next() {
		var i GetLiveTrainsRow
		if err := rows.Scan(
			&i.TrainName,
			&i.TrainType,
			&i.TrainNo,
			&i.LatU6,
			&i.LngU6,
			&i.BearingDeg,
			&i.CurrentStatus,
			&i.LastUpdateTimestampIso,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
