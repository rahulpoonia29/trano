// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries_poller.sql

package db

import (
	"context"
	"database/sql"

	"trano/internal/db"
)

const clearRunningDayBitForDate = `-- name: ClearRunningDayBitForDate :exec
UPDATE train_schedules
SET
    running_days_bitmap =
        running_days_bitmap &
        ~(1 << CAST(strftime('%w', @run_date) AS INTEGER)),
    updated_at = CURRENT_TIMESTAMP
WHERE schedule_id = ?1
  AND (
        running_days_bitmap &
        (1 << CAST(strftime('%w', ?2) AS INTEGER))
      ) <> 0
`

type ClearRunningDayBitForDateParams struct {
	ScheduleID int64       `json:"schedule_id"`
	RunDate    interface{} `json:"run_date"`
}

func (q *Queries) ClearRunningDayBitForDate(ctx context.Context, arg ClearRunningDayBitForDateParams) error {
	_, err := q.db.ExecContext(ctx, clearRunningDayBitForDate, arg.ScheduleID, arg.RunDate)
	return err
}

const getRunSnap = `-- name: GetRunSnap :one
WITH snapped AS (
  SELECT
    ST_ClosestPoint(
      trg.route_geom,
      ST_Transform(MakePoint(?1, ?2, 4326), 7755)
    ) AS snappt,
    trg.route_geom
  FROM train_runs tr
  JOIN train_route_geometries trg
    ON tr.schedule_id = trg.schedule_id
  WHERE tr.run_id = ?3
    AND ST_IsValid(trg.route_geom) = 1
),
fraccalc AS (
  SELECT
    snappt,
    route_geom,
    Line_Locate_Point(route_geom, snappt) AS frac
  FROM snapped
),
bearingcalc AS (
  SELECT
    snappt,
    route_geom,
    frac,
    CASE
      WHEN frac >= 0.999 THEN
        ST_Azimuth(
          ST_Line_Interpolate_Point(route_geom, MAX(0.0, frac - 0.0005)),
          snappt
        )
      ELSE
        ST_Azimuth(
          snappt,
          ST_Line_Interpolate_Point(route_geom, MIN(1.0, frac + 0.0005))
        )
    END AS bearing_rad
  FROM fraccalc
)
SELECT
  CAST(X(ST_Transform(snappt, 4326)) * 1000000 AS INTEGER) AS snapped_lng_u6,
  CAST(Y(ST_Transform(snappt, 4326)) * 1000000 AS INTEGER) AS snapped_lat_u6,
  CAST(frac * 10000 AS INTEGER) AS route_frac_u4,
  CAST(ROUND(Degrees(bearing_rad)) % 360 AS INTEGER) AS bearing_deg
FROM bearingcalc
`

type GetRunSnapParams struct {
	Lng   interface{} `json:"lng"`
	Lat   interface{} `json:"lat"`
	RunID string      `json:"run_id"`
}

type GetRunSnapRow struct {
	SnappedLngU6 int64 `json:"snapped_lng_u6"`
	SnappedLatU6 int64 `json:"snapped_lat_u6"`
	RouteFracU4  int64 `json:"route_frac_u4"`
	BearingDeg   int64 `json:"bearing_deg"`
}

// Snap raw GPS to route and compute linear reference bearing
func (q *Queries) GetRunSnap(ctx context.Context, arg GetRunSnapParams) (GetRunSnapRow, error) {
	row := q.db.QueryRowContext(ctx, getRunSnap, arg.Lng, arg.Lat, arg.RunID)
	var i GetRunSnapRow
	err := row.Scan(
		&i.SnappedLngU6,
		&i.SnappedLatU6,
		&i.RouteFracU4,
		&i.BearingDeg,
	)
	return i, err
}

const listRunsToPoll = `-- name: ListRunsToPoll :many
SELECT
    tr.run_id,
    tr.train_no,
    tr.run_date,
    tr.last_known_lat_u6,
    tr.last_known_lng_u6,
    tr.last_updated_sno,
    tr.last_update_timestamp_ISO,
    COALESCE(tr.errors, '{}') AS errors,
    ts.schedule_id,
    ts.origin_station_code AS source_station,
    ts.terminus_station_code AS destination_station
FROM train_runs tr
JOIN train_schedules ts
    ON tr.schedule_id = ts.schedule_id
WHERE tr.has_arrived = 0
  AND date(tr.run_date) <= date(?1)
  AND date(tr.run_date) >= date(?1, '-5 days')
  AND COALESCE(json_extract(tr.errors, '$.static_response.count'), 0)
        < CAST(?2 AS INTEGER)
  AND (
        COALESCE(json_extract(tr.errors, '$.static_response.count'), 0) +
        COALESCE(json_extract(tr.errors, '$.api_error.count'), 0) +
        COALESCE(json_extract(tr.errors, '$.unknown.count'), 0)
      ) < CAST(?3 AS INTEGER)
  AND datetime(
        tr.run_date || ' ' ||
        printf(
            '%02d:%02d',
            ts.origin_sch_departure_min / 60,
            ts.origin_sch_departure_min % 60
        )
      ) <= datetime(?1)
ORDER BY tr.last_update_timestamp_ISO ASC NULLS FIRST
`

type ListRunsToPollParams struct {
	NowTs                   interface{} `json:"now_ts"`
	StaticResponseThreshold int64       `json:"static_response_threshold"`
	TotalErrorThreshold     int64       `json:"total_error_threshold"`
}

type ListRunsToPollRow struct {
	RunID                  string         `json:"run_id"`
	TrainNo                int64          `json:"train_no"`
	RunDate                string         `json:"run_date"`
	LastKnownLatU6         sql.NullInt64  `json:"last_known_lat_u6"`
	LastKnownLngU6         sql.NullInt64  `json:"last_known_lng_u6"`
	LastUpdatedSno         sql.NullString `json:"last_updated_sno"`
	LastUpdateTimestampIso sql.NullString `json:"last_update_timestamp_iso"`
	Errors                 db.RunErrors   `json:"errors"`
	ScheduleID             int64          `json:"schedule_id"`
	SourceStation          string         `json:"source_station"`
	DestinationStation     string         `json:"destination_station"`
}

// Fetch active runs with error threshold and start-time gating
func (q *Queries) ListRunsToPoll(ctx context.Context, arg ListRunsToPollParams) ([]ListRunsToPollRow, error) {
	rows, err := q.db.QueryContext(ctx, listRunsToPoll, arg.NowTs, arg.StaticResponseThreshold, arg.TotalErrorThreshold)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRunsToPollRow{}
	for rows.Next() {
		var i ListRunsToPollRow
		if err := rows.Scan(
			&i.RunID,
			&i.TrainNo,
			&i.RunDate,
			&i.LastKnownLatU6,
			&i.LastKnownLngU6,
			&i.LastUpdatedSno,
			&i.LastUpdateTimestampIso,
			&i.Errors,
			&i.ScheduleID,
			&i.SourceStation,
			&i.DestinationStation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logRunLocation = `-- name: LogRunLocation :exec
INSERT INTO train_run_locations (
    run_id,
    lat_u6,
    lng_u6,
    snapped_lat_u6,
    snapped_lng_u6,
    distance_km_u4,
    segment_station_code,
    at_station,
    timestamp_ISO
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6,
    ?7,
    ?8,
    ?9
)
ON CONFLICT(run_id, timestamp_ISO) DO NOTHING
`

type LogRunLocationParams struct {
	RunID              string        `json:"run_id"`
	LatU6              int64         `json:"lat_u6"`
	LngU6              int64         `json:"lng_u6"`
	SnappedLatU6       sql.NullInt64 `json:"snapped_lat_u6"`
	SnappedLngU6       sql.NullInt64 `json:"snapped_lng_u6"`
	DistanceKmU4       int64         `json:"distance_km_u4"`
	SegmentStationCode string        `json:"segment_station_code"`
	AtStation          int64         `json:"at_station"`
	TimestampIso       string        `json:"timestamp_iso"`
}

func (q *Queries) LogRunLocation(ctx context.Context, arg LogRunLocationParams) error {
	_, err := q.db.ExecContext(ctx, logRunLocation,
		arg.RunID,
		arg.LatU6,
		arg.LngU6,
		arg.SnappedLatU6,
		arg.SnappedLngU6,
		arg.DistanceKmU4,
		arg.SegmentStationCode,
		arg.AtStation,
		arg.TimestampIso,
	)
	return err
}

const updateRunStatus = `-- name: UpdateRunStatus :exec
UPDATE train_runs
SET
    has_started = COALESCE(?1, has_started),
    has_arrived = COALESCE(?2, has_arrived),
    current_status = COALESCE(?3, current_status),
    last_known_lat_u6 = COALESCE(?4, last_known_lat_u6),
    last_known_lng_u6 = COALESCE(?5, last_known_lng_u6),
    last_known_snapped_lat_u6 = COALESCE(?6, last_known_snapped_lat_u6),
    last_known_snapped_lng_u6 = COALESCE(?7, last_known_snapped_lng_u6),
    last_route_frac_u4 = COALESCE(?8, last_route_frac_u4),
    last_bearing_deg = COALESCE(?9, last_bearing_deg),
    last_known_distance_km_u4 = COALESCE(?10, last_known_distance_km_u4),
    errors = COALESCE(?11, errors),
    last_updated_sno = COALESCE(?12, last_updated_sno),
    last_update_timestamp_ISO = COALESCE(?13, last_update_timestamp_ISO),
    updated_at = CURRENT_TIMESTAMP
WHERE run_id = ?14
`

type UpdateRunStatusParams struct {
	HasStarted     int64          `json:"has_started"`
	HasArrived     int64          `json:"has_arrived"`
	CurrentStatus  interface{}    `json:"current_status"`
	LatU6          sql.NullInt64  `json:"lat_u6"`
	LngU6          sql.NullInt64  `json:"lng_u6"`
	SnappedLatU6   sql.NullInt64  `json:"snapped_lat_u6"`
	SnappedLngU6   sql.NullInt64  `json:"snapped_lng_u6"`
	RouteFracU4    sql.NullInt64  `json:"route_frac_u4"`
	BearingDeg     sql.NullInt64  `json:"bearing_deg"`
	DistanceKmU4   sql.NullInt64  `json:"distance_km_u4"`
	Errors         db.RunErrors   `json:"errors"`
	LastUpdatedSno sql.NullString `json:"last_updated_sno"`
	LastUpdateIso  sql.NullString `json:"last_update_iso"`
	RunID          string         `json:"run_id"`
}

// Partial, idempotent update of run state
func (q *Queries) UpdateRunStatus(ctx context.Context, arg UpdateRunStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateRunStatus,
		arg.HasStarted,
		arg.HasArrived,
		arg.CurrentStatus,
		arg.LatU6,
		arg.LngU6,
		arg.SnappedLatU6,
		arg.SnappedLngU6,
		arg.RouteFracU4,
		arg.BearingDeg,
		arg.DistanceKmU4,
		arg.Errors,
		arg.LastUpdatedSno,
		arg.LastUpdateIso,
		arg.RunID,
	)
	return err
}
