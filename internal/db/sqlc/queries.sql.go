// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
)

const listActiveSchedules = `-- name: ListActiveSchedules :many
SELECT
  schedule_id,
  train_no,
  origin_station_code,
  terminus_station_code
FROM train_schedules ts
WHERE (ts.running_days_bitmap & (1 << ?1)) <> 0
`

type ListActiveSchedulesRow struct {
	ScheduleID          int64  `json:"schedule_id"`
	TrainNo             int64  `json:"train_no"`
	OriginStationCode   string `json:"origin_station_code"`
	TerminusStationCode string `json:"terminus_station_code"`
}

// Returns schedules valid for the given date to generate runs
func (q *Queries) ListActiveSchedules(ctx context.Context, weekday interface{}) ([]ListActiveSchedulesRow, error) {
	rows, err := q.db.QueryContext(ctx, listActiveSchedules, weekday)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActiveSchedulesRow{}
	for rows.Next() {
		var i ListActiveSchedulesRow
		if err := rows.Scan(
			&i.ScheduleID,
			&i.TrainNo,
			&i.OriginStationCode,
			&i.TerminusStationCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRunsToPoll = `-- name: ListRunsToPoll :many
SELECT
    tr.run_id,
    tr.train_no,
    tr.run_date,
    tr.last_known_lat,
    tr.last_known_lng,
    tr.last_update_timestamp_ISO,
    tr.errors,
    ts.origin_station_code AS source_station,
    ts.terminus_station_code AS destination_station
  FROM train_runs tr
  JOIN train_schedules ts ON tr.schedule_id = ts.schedule_id
  WHERE tr.has_arrived = 0
    AND date(tr.run_date) = date(CAST(?1 AS TEXT))
    AND COALESCE(json_array_length(tr.errors), 0) < CAST(?2 AS INTEGER)
  ORDER BY tr.last_update_timestamp_ISO ASC NULLS FIRST
`

type ListRunsToPollParams struct {
	TargetDate string `json:"target_date"`
	Threshold  int64  `json:"threshold"`
}

type ListRunsToPollRow struct {
	RunID                  string          `json:"run_id"`
	TrainNo                int64           `json:"train_no"`
	RunDate                string          `json:"run_date"`
	LastKnownLat           sql.NullFloat64 `json:"last_known_lat"`
	LastKnownLng           sql.NullFloat64 `json:"last_known_lng"`
	LastUpdateTimestampIso sql.NullString  `json:"last_update_timestamp_iso"`
	Errors                 json.RawMessage `json:"errors"`
	SourceStation          string          `json:"source_station"`
	DestinationStation     string          `json:"destination_station"`
}

// Fetches active runs with error threshold check. Join to get source/dest for API params.
func (q *Queries) ListRunsToPoll(ctx context.Context, arg ListRunsToPollParams) ([]ListRunsToPollRow, error) {
	rows, err := q.db.QueryContext(ctx, listRunsToPoll, arg.TargetDate, arg.Threshold)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRunsToPollRow{}
	for rows.Next() {
		var i ListRunsToPollRow
		if err := rows.Scan(
			&i.RunID,
			&i.TrainNo,
			&i.RunDate,
			&i.LastKnownLat,
			&i.LastKnownLng,
			&i.LastUpdateTimestampIso,
			&i.Errors,
			&i.SourceStation,
			&i.DestinationStation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logRunLocation = `-- name: LogRunLocation :exec
INSERT INTO train_run_locations (
  run_id, lat, lng, timestamp_ISO
) VALUES (
  ?1, ?2, ?3, ?4
)
ON CONFLICT(run_id, timestamp_ISO) DO NOTHING
`

type LogRunLocationParams struct {
	RunID        string  `json:"run_id"`
	Lat          float64 `json:"lat"`
	Lng          float64 `json:"lng"`
	TimestampIso string  `json:"timestamp_iso"`
}

// Inserts into the time-series tracking table
func (q *Queries) LogRunLocation(ctx context.Context, arg LogRunLocationParams) error {
	_, err := q.db.ExecContext(ctx, logRunLocation,
		arg.RunID,
		arg.Lat,
		arg.Lng,
		arg.TimestampIso,
	)
	return err
}

const updateRunStatus = `-- name: UpdateRunStatus :exec
UPDATE train_runs
SET
  has_started               = COALESCE(?1, has_started),
  has_arrived               = COALESCE(?2, has_arrived),
  end_reason                = COALESCE(?3, end_reason),
  last_known_lat            = COALESCE(?4, last_known_lat),
  last_known_lng            = COALESCE(?5, last_known_lng),
  last_update_timestamp_ISO = COALESCE(?6, last_update_timestamp_ISO),
  errors                    = COALESCE(?7, errors),
  updated_at                = CURRENT_TIMESTAMP
WHERE run_id = ?8
`

type UpdateRunStatusParams struct {
	HasStarted    int64           `json:"has_started"`
	HasArrived    int64           `json:"has_arrived"`
	EndReason     sql.NullString  `json:"end_reason"`
	Lat           sql.NullFloat64 `json:"lat"`
	Lng           sql.NullFloat64 `json:"lng"`
	LastUpdateIso sql.NullString  `json:"last_update_iso"`
	Errors        json.RawMessage `json:"errors"`
	RunID         string          `json:"run_id"`
}

// Updates the main run state (use COALESCE pattern for partial updates)
func (q *Queries) UpdateRunStatus(ctx context.Context, arg UpdateRunStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateRunStatus,
		arg.HasStarted,
		arg.HasArrived,
		arg.EndReason,
		arg.Lat,
		arg.Lng,
		arg.LastUpdateIso,
		arg.Errors,
		arg.RunID,
	)
	return err
}

const upsertTrainRun = `-- name: UpsertTrainRun :exec
INSERT INTO train_runs (
  run_id,
  schedule_id,
  train_no,
  run_date,
  has_started,
  has_arrived,
  created_at,
  updated_at
) VALUES (
  ?1,
  ?2,
  ?3,
  ?4,
  0,
  0,
  CURRENT_TIMESTAMP,
  CURRENT_TIMESTAMP
)
ON CONFLICT(run_id) DO UPDATE
SET
  schedule_id = excluded.schedule_id,
  updated_at = CURRENT_TIMESTAMP
`

type UpsertTrainRunParams struct {
	RunID      string `json:"run_id"`
	ScheduleID int64  `json:"schedule_id"`
	TrainNo    int64  `json:"train_no"`
	RunDate    string `json:"run_date"`
}

// Creates a run instance. run_id format: trainNo_YYYY-MM-DD
func (q *Queries) UpsertTrainRun(ctx context.Context, arg UpsertTrainRunParams) error {
	_, err := q.db.ExecContext(ctx, upsertTrainRun,
		arg.RunID,
		arg.ScheduleID,
		arg.TrainNo,
		arg.RunDate,
	)
	return err
}
