// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"

	"trano/internal/db"
)

const clearRunningDayBitForDate = `-- name: ClearRunningDayBitForDate :exec
UPDATE train_schedules
SET
    running_days_bitmap =
        running_days_bitmap &
        ~(1 << CAST(strftime('%w', @run_date) AS INTEGER)),
    updated_at = CURRENT_TIMESTAMP
WHERE schedule_id = ?1
  AND (
        running_days_bitmap &
        (1 << CAST(strftime('%w', ?2) AS INTEGER))
      ) <> 0
`

type ClearRunningDayBitForDateParams struct {
	ScheduleID int64       `json:"schedule_id"`
	RunDate    interface{} `json:"run_date"`
}

func (q *Queries) ClearRunningDayBitForDate(ctx context.Context, arg ClearRunningDayBitForDateParams) error {
	_, err := q.db.ExecContext(ctx, clearRunningDayBitForDate, arg.ScheduleID, arg.RunDate)
	return err
}

const generateRunsForDate = `-- name: GenerateRunsForDate :exec
INSERT INTO train_runs (
    run_id,
    schedule_id,
    train_no,
    run_date
)
SELECT
    printf('%d_%s', ts.train_no, ?1) AS run_id,
    ts.schedule_id,
    ts.train_no,
    ?1
FROM train_schedules ts
JOIN trains t
    ON ts.train_no = t.train_no
WHERE (ts.running_days_bitmap & (1 << ?2)) <> 0
ON CONFLICT (train_no, run_date) DO NOTHING
`

type GenerateRunsForDateParams struct {
	RunDate string      `json:"run_date"`
	Weekday interface{} `json:"weekday"`
}

func (q *Queries) GenerateRunsForDate(ctx context.Context, arg GenerateRunsForDateParams) error {
	_, err := q.db.ExecContext(ctx, generateRunsForDate, arg.RunDate, arg.Weekday)
	return err
}

const getRunSnap = `-- name: GetRunSnap :one
WITH snapped AS (
  SELECT
    ST_ClosestPoint(
      trg.route_geom,
      ST_Transform(MakePoint(?1, ?2, 4326), 7755)
    ) AS snappt,
    trg.route_geom
  FROM train_runs tr
  JOIN train_route_geometries trg
    ON tr.schedule_id = trg.schedule_id
  WHERE tr.run_id = ?3
    AND ST_IsValid(trg.route_geom) = 1
),
fraccalc AS (
  SELECT
    snappt,
    route_geom,
    ST_Distance(ST_StartPoint(route_geom), snappt) /
      NULLIF(ST_Length(route_geom), 1.0) AS frac
  FROM snapped
),
bearingcalc AS (
  SELECT
    snappt,
    route_geom,
    frac,
    CASE
      WHEN frac >= 0.999 THEN
        ST_Azimuth(
          ST_Line_Interpolate_Point(route_geom, MAX(0.0, frac - 0.0005)),
          snappt
        )
      ELSE
        ST_Azimuth(
          snappt,
          ST_Line_Interpolate_Point(route_geom, MIN(1.0, frac + 0.0005))
        )
    END AS bearing_rad
  FROM fraccalc
)
SELECT
  CAST(X(ST_Transform(snappt, 4326)) * 1000000 AS INTEGER) AS snapped_lng_u6,
  CAST(Y(ST_Transform(snappt, 4326)) * 1000000 AS INTEGER) AS snapped_lat_u6,
  CAST(frac * 10000 AS INTEGER) AS route_frac_u4,
  CAST(ROUND(Degrees(bearing_rad)) % 360 AS INTEGER) AS bearing_deg
FROM bearingcalc
`

type GetRunSnapParams struct {
	Lng   interface{} `json:"lng"`
	Lat   interface{} `json:"lat"`
	RunID string      `json:"run_id"`
}

type GetRunSnapRow struct {
	SnappedLngU6 int64 `json:"snapped_lng_u6"`
	SnappedLatU6 int64 `json:"snapped_lat_u6"`
	RouteFracU4  int64 `json:"route_frac_u4"`
	BearingDeg   int64 `json:"bearing_deg"`
}

// Snap raw GPS to route and compute linear reference bearing
func (q *Queries) GetRunSnap(ctx context.Context, arg GetRunSnapParams) (GetRunSnapRow, error) {
	row := q.db.QueryRowContext(ctx, getRunSnap, arg.Lng, arg.Lat, arg.RunID)
	var i GetRunSnapRow
	err := row.Scan(
		&i.SnappedLngU6,
		&i.SnappedLatU6,
		&i.RouteFracU4,
		&i.BearingDeg,
	)
	return i, err
}

const getTrainsInViewport = `-- name: GetTrainsInViewport :many
SELECT 
    tr.train_no,
    tr.last_known_snapped_lat_u6 AS lat_u6,
    tr.last_known_snapped_lng_u6 AS lng_u6,
    tr.last_bearing_deg AS bearing_deg,
    tr.current_status,
    tr.last_update_timestamp_iso,
    t.train_name,
    t.train_type
FROM train_runs tr
JOIN trains t ON tr.train_no = t.train_no
WHERE tr.has_arrived = 0
  AND tr.last_known_snapped_lat_u6 IS NOT NULL
  AND tr.last_known_snapped_lng_u6 IS NOT NULL
  -- Spatial bounds filter (with u6 encoding)
  AND tr.last_known_snapped_lat_u6 >= ?1
  AND tr.last_known_snapped_lat_u6 <= ?2
  AND tr.last_known_snapped_lng_u6 >= ?3
  AND tr.last_known_snapped_lng_u6 <= ?4
  -- Only recent updates (avoid stale data)
  AND datetime(tr.last_update_timestamp_iso) > datetime('now', '-10 minutes')
ORDER BY tr.last_update_timestamp_iso DESC
`

type GetTrainsInViewportParams struct {
	MinLatU6 sql.NullInt64 `json:"min_lat_u6"`
	MaxLatU6 sql.NullInt64 `json:"max_lat_u6"`
	MinLngU6 sql.NullInt64 `json:"min_lng_u6"`
	MaxLngU6 sql.NullInt64 `json:"max_lng_u6"`
}

type GetTrainsInViewportRow struct {
	TrainNo                int64          `json:"train_no"`
	LatU6                  sql.NullInt64  `json:"lat_u6"`
	LngU6                  sql.NullInt64  `json:"lng_u6"`
	BearingDeg             sql.NullInt64  `json:"bearing_deg"`
	CurrentStatus          interface{}    `json:"current_status"`
	LastUpdateTimestampIso sql.NullString `json:"last_update_timestamp_iso"`
	TrainName              string         `json:"train_name"`
	TrainType              string         `json:"train_type"`
}

// Returns data for active trains within viewport bounds
func (q *Queries) GetTrainsInViewport(ctx context.Context, arg GetTrainsInViewportParams) ([]GetTrainsInViewportRow, error) {
	rows, err := q.db.QueryContext(ctx, getTrainsInViewport,
		arg.MinLatU6,
		arg.MaxLatU6,
		arg.MinLngU6,
		arg.MaxLngU6,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTrainsInViewportRow{}
	for rows.Next() {
		var i GetTrainsInViewportRow
		if err := rows.Scan(
			&i.TrainNo,
			&i.LatU6,
			&i.LngU6,
			&i.BearingDeg,
			&i.CurrentStatus,
			&i.LastUpdateTimestampIso,
			&i.TrainName,
			&i.TrainType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRunsToPoll = `-- name: ListRunsToPoll :many
SELECT
    tr.run_id,
    tr.train_no,
    tr.run_date,
    tr.last_known_lat_u6,
    tr.last_known_lng_u6,
    tr.last_updated_sno,
    tr.last_update_timestamp_ISO,
    COALESCE(tr.errors, '{}') AS errors,
    ts.schedule_id,
    ts.origin_station_code AS source_station,
    ts.terminus_station_code AS destination_station
FROM train_runs tr
JOIN train_schedules ts
    ON tr.schedule_id = ts.schedule_id
WHERE tr.has_arrived = 0
  AND date(tr.run_date) <= date(?1)
  AND date(tr.run_date) >= date(?1, '-5 days')
  AND COALESCE(json_extract(tr.errors, '$.static_response.count'), 0)
        < CAST(?2 AS INTEGER)
  AND (
        COALESCE(json_extract(tr.errors, '$.static_response.count'), 0) +
        COALESCE(json_extract(tr.errors, '$.api_error.count'), 0) +
        COALESCE(json_extract(tr.errors, '$.unknown.count'), 0)
      ) < CAST(?3 AS INTEGER)
  AND datetime(
        tr.run_date || ' ' ||
        printf(
            '%02d:%02d',
            ts.origin_sch_departure_min / 60,
            ts.origin_sch_departure_min % 60
        )
      ) <= datetime(?1)
ORDER BY tr.last_update_timestamp_ISO ASC NULLS FIRST
`

type ListRunsToPollParams struct {
	NowTs                   interface{} `json:"now_ts"`
	StaticResponseThreshold int64       `json:"static_response_threshold"`
	TotalErrorThreshold     int64       `json:"total_error_threshold"`
}

type ListRunsToPollRow struct {
	RunID                  string         `json:"run_id"`
	TrainNo                int64          `json:"train_no"`
	RunDate                string         `json:"run_date"`
	LastKnownLatU6         sql.NullInt64  `json:"last_known_lat_u6"`
	LastKnownLngU6         sql.NullInt64  `json:"last_known_lng_u6"`
	LastUpdatedSno         sql.NullString `json:"last_updated_sno"`
	LastUpdateTimestampIso sql.NullString `json:"last_update_timestamp_iso"`
	Errors                 db.RunErrors   `json:"errors"`
	ScheduleID             int64          `json:"schedule_id"`
	SourceStation          string         `json:"source_station"`
	DestinationStation     string         `json:"destination_station"`
}

// Fetch active runs with error threshold and start-time gating
func (q *Queries) ListRunsToPoll(ctx context.Context, arg ListRunsToPollParams) ([]ListRunsToPollRow, error) {
	rows, err := q.db.QueryContext(ctx, listRunsToPoll, arg.NowTs, arg.StaticResponseThreshold, arg.TotalErrorThreshold)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRunsToPollRow{}
	for rows.Next() {
		var i ListRunsToPollRow
		if err := rows.Scan(
			&i.RunID,
			&i.TrainNo,
			&i.RunDate,
			&i.LastKnownLatU6,
			&i.LastKnownLngU6,
			&i.LastUpdatedSno,
			&i.LastUpdateTimestampIso,
			&i.Errors,
			&i.ScheduleID,
			&i.SourceStation,
			&i.DestinationStation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logRunLocation = `-- name: LogRunLocation :exec
INSERT INTO train_run_locations (
    run_id,
    lat_u6,
    lng_u6,
    snapped_lat_u6,
    snapped_lng_u6,
    distance_km_u4,
    segment_station_code,
    at_station,
    timestamp_ISO
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6,
    ?7,
    ?8,
    ?9
)
ON CONFLICT(run_id, timestamp_ISO) DO NOTHING
`

type LogRunLocationParams struct {
	RunID              string        `json:"run_id"`
	LatU6              int64         `json:"lat_u6"`
	LngU6              int64         `json:"lng_u6"`
	SnappedLatU6       sql.NullInt64 `json:"snapped_lat_u6"`
	SnappedLngU6       sql.NullInt64 `json:"snapped_lng_u6"`
	DistanceKmU4       int64         `json:"distance_km_u4"`
	SegmentStationCode string        `json:"segment_station_code"`
	AtStation          int64         `json:"at_station"`
	TimestampIso       string        `json:"timestamp_iso"`
}

func (q *Queries) LogRunLocation(ctx context.Context, arg LogRunLocationParams) error {
	_, err := q.db.ExecContext(ctx, logRunLocation,
		arg.RunID,
		arg.LatU6,
		arg.LngU6,
		arg.SnappedLatU6,
		arg.SnappedLngU6,
		arg.DistanceKmU4,
		arg.SegmentStationCode,
		arg.AtStation,
		arg.TimestampIso,
	)
	return err
}

const updateRunStatus = `-- name: UpdateRunStatus :exec
UPDATE train_runs
SET
    has_started = COALESCE(?1, has_started),
    has_arrived = COALESCE(?2, has_arrived),
    current_status = COALESCE(?3, current_status),
    last_known_lat_u6 = COALESCE(?4, last_known_lat_u6),
    last_known_lng_u6 = COALESCE(?5, last_known_lng_u6),
    last_known_snapped_lat_u6 = COALESCE(?6, last_known_snapped_lat_u6),
    last_known_snapped_lng_u6 = COALESCE(?7, last_known_snapped_lng_u6),
    last_route_frac_u4 = COALESCE(?8, last_route_frac_u4),
    last_bearing_deg = COALESCE(?9, last_bearing_deg),
    last_known_distance_km_u4 = COALESCE(?10, last_known_distance_km_u4),
    errors = COALESCE(?11, errors),
    last_updated_sno = COALESCE(?12, last_updated_sno),
    last_update_timestamp_ISO = COALESCE(?13, last_update_timestamp_ISO),
    updated_at = CURRENT_TIMESTAMP
WHERE run_id = ?14
`

type UpdateRunStatusParams struct {
	HasStarted     int64          `json:"has_started"`
	HasArrived     int64          `json:"has_arrived"`
	CurrentStatus  interface{}    `json:"current_status"`
	LatU6          sql.NullInt64  `json:"lat_u6"`
	LngU6          sql.NullInt64  `json:"lng_u6"`
	SnappedLatU6   sql.NullInt64  `json:"snapped_lat_u6"`
	SnappedLngU6   sql.NullInt64  `json:"snapped_lng_u6"`
	RouteFracU4    sql.NullInt64  `json:"route_frac_u4"`
	BearingDeg     sql.NullInt64  `json:"bearing_deg"`
	DistanceKmU4   sql.NullInt64  `json:"distance_km_u4"`
	Errors         db.RunErrors   `json:"errors"`
	LastUpdatedSno sql.NullString `json:"last_updated_sno"`
	LastUpdateIso  sql.NullString `json:"last_update_iso"`
	RunID          string         `json:"run_id"`
}

// Partial, idempotent update of run state
func (q *Queries) UpdateRunStatus(ctx context.Context, arg UpdateRunStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateRunStatus,
		arg.HasStarted,
		arg.HasArrived,
		arg.CurrentStatus,
		arg.LatU6,
		arg.LngU6,
		arg.SnappedLatU6,
		arg.SnappedLngU6,
		arg.RouteFracU4,
		arg.BearingDeg,
		arg.DistanceKmU4,
		arg.Errors,
		arg.LastUpdatedSno,
		arg.LastUpdateIso,
		arg.RunID,
	)
	return err
}

const upsertStation = `-- name: UpsertStation :exec
INSERT INTO stations (
    station_code,
    station_name,
    zone,
    division,
    address,
    elevation_m,
    lat,
    lng,
    number_of_platforms,
    station_type,
    station_category,
    track_type,
    updated_at
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6,
    ?7,
    ?8,
    ?9,
    ?10,
    ?11,
    ?12,
    CURRENT_TIMESTAMP
)
ON CONFLICT(station_code) DO UPDATE SET
    station_name = excluded.station_name,
    zone = excluded.zone,
    division = excluded.division,
    address = excluded.address,
    elevation_m = excluded.elevation_m,
    lat = excluded.lat,
    lng = excluded.lng,
    number_of_platforms = excluded.number_of_platforms,
    station_type = excluded.station_type,
    station_category = excluded.station_category,
    track_type = excluded.track_type,
    updated_at = CURRENT_TIMESTAMP
`

type UpsertStationParams struct {
	StationCode       string          `json:"station_code"`
	StationName       string          `json:"station_name"`
	Zone              sql.NullString  `json:"zone"`
	Division          sql.NullString  `json:"division"`
	Address           sql.NullString  `json:"address"`
	ElevationM        sql.NullFloat64 `json:"elevation_m"`
	Lat               sql.NullFloat64 `json:"lat"`
	Lng               sql.NullFloat64 `json:"lng"`
	NumberOfPlatforms sql.NullInt64   `json:"number_of_platforms"`
	StationType       sql.NullString  `json:"station_type"`
	StationCategory   sql.NullString  `json:"station_category"`
	TrackType         sql.NullString  `json:"track_type"`
}

func (q *Queries) UpsertStation(ctx context.Context, arg UpsertStationParams) error {
	_, err := q.db.ExecContext(ctx, upsertStation,
		arg.StationCode,
		arg.StationName,
		arg.Zone,
		arg.Division,
		arg.Address,
		arg.ElevationM,
		arg.Lat,
		arg.Lng,
		arg.NumberOfPlatforms,
		arg.StationType,
		arg.StationCategory,
		arg.TrackType,
	)
	return err
}

const upsertTrain = `-- name: UpsertTrain :exec
INSERT INTO trains (
    train_no,
    train_name,
    train_type,
    zone,
    return_train_no,
    coachComposition,
    source_url,
    created_at,
    updated_at
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6,
    ?7,
    COALESCE(?8, CURRENT_TIMESTAMP),
    CURRENT_TIMESTAMP
)
ON CONFLICT(train_no) DO UPDATE SET
    train_name = excluded.train_name,
    train_type = excluded.train_type,
    zone = excluded.zone,
    return_train_no = excluded.return_train_no,
    coachComposition = excluded.coachComposition,
    source_url = excluded.source_url,
    updated_at = CURRENT_TIMESTAMP
`

type UpsertTrainParams struct {
	TrainNo          int64          `json:"train_no"`
	TrainName        string         `json:"train_name"`
	TrainType        string         `json:"train_type"`
	Zone             sql.NullString `json:"zone"`
	ReturnTrainNo    sql.NullInt64  `json:"return_train_no"`
	CoachComposition sql.NullString `json:"coachComposition"`
	SourceUrl        string         `json:"source_url"`
	CreatedAt        interface{}    `json:"created_at"`
}

func (q *Queries) UpsertTrain(ctx context.Context, arg UpsertTrainParams) error {
	_, err := q.db.ExecContext(ctx, upsertTrain,
		arg.TrainNo,
		arg.TrainName,
		arg.TrainType,
		arg.Zone,
		arg.ReturnTrainNo,
		arg.CoachComposition,
		arg.SourceUrl,
		arg.CreatedAt,
	)
	return err
}

const upsertTrainRoute = `-- name: UpsertTrainRoute :exec
INSERT INTO train_routes (
    schedule_id,
    station_code,
    distance_km,
    sch_arrival_min_from_start,
    sch_departure_min_from_start,
    stops
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6
)
ON CONFLICT(schedule_id, station_code) DO UPDATE SET
    distance_km = excluded.distance_km,
    sch_arrival_min_from_start = excluded.sch_arrival_min_from_start,
    sch_departure_min_from_start = excluded.sch_departure_min_from_start,
    stops = excluded.stops
`

type UpsertTrainRouteParams struct {
	ScheduleID               int64   `json:"schedule_id"`
	StationCode              string  `json:"station_code"`
	DistanceKm               float64 `json:"distance_km"`
	SchArrivalMinFromStart   int64   `json:"sch_arrival_min_from_start"`
	SchDepartureMinFromStart int64   `json:"sch_departure_min_from_start"`
	Stops                    int64   `json:"stops"`
}

func (q *Queries) UpsertTrainRoute(ctx context.Context, arg UpsertTrainRouteParams) error {
	_, err := q.db.ExecContext(ctx, upsertTrainRoute,
		arg.ScheduleID,
		arg.StationCode,
		arg.DistanceKm,
		arg.SchArrivalMinFromStart,
		arg.SchDepartureMinFromStart,
		arg.Stops,
	)
	return err
}

const upsertTrainRun = `-- name: UpsertTrainRun :exec
INSERT INTO train_runs (
    run_id,
    schedule_id,
    train_no,
    run_date,
    created_at,
    updated_at
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP
)
ON CONFLICT(run_id) DO UPDATE SET
    schedule_id = excluded.schedule_id,
    updated_at = CURRENT_TIMESTAMP
`

type UpsertTrainRunParams struct {
	RunID      string `json:"run_id"`
	ScheduleID int64  `json:"schedule_id"`
	TrainNo    int64  `json:"train_no"`
	RunDate    string `json:"run_date"`
}

func (q *Queries) UpsertTrainRun(ctx context.Context, arg UpsertTrainRunParams) error {
	_, err := q.db.ExecContext(ctx, upsertTrainRun,
		arg.RunID,
		arg.ScheduleID,
		arg.TrainNo,
		arg.RunDate,
	)
	return err
}

const upsertTrainSchedule = `-- name: UpsertTrainSchedule :one
INSERT INTO train_schedules (
    train_no,
    origin_station_code,
    terminus_station_code,
    origin_sch_departure_min,
    total_distance_km,
    total_runtime_min,
    running_days_bitmap,
    created_at,
    updated_at
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6,
    ?7,
    COALESCE(?8, CURRENT_TIMESTAMP),
    CURRENT_TIMESTAMP
)
ON CONFLICT(
    train_no,
    origin_station_code,
    terminus_station_code,
    origin_sch_departure_min
) DO UPDATE SET
    total_distance_km = excluded.total_distance_km,
    total_runtime_min = excluded.total_runtime_min,
    running_days_bitmap = excluded.running_days_bitmap,
    updated_at = CURRENT_TIMESTAMP
RETURNING schedule_id
`

type UpsertTrainScheduleParams struct {
	TrainNo               int64       `json:"train_no"`
	OriginStationCode     string      `json:"origin_station_code"`
	TerminusStationCode   string      `json:"terminus_station_code"`
	OriginSchDepartureMin int64       `json:"origin_sch_departure_min"`
	TotalDistanceKm       float64     `json:"total_distance_km"`
	TotalRuntimeMin       int64       `json:"total_runtime_min"`
	RunningDaysBitmap     int64       `json:"running_days_bitmap"`
	CreatedAt             interface{} `json:"created_at"`
}

func (q *Queries) UpsertTrainSchedule(ctx context.Context, arg UpsertTrainScheduleParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, upsertTrainSchedule,
		arg.TrainNo,
		arg.OriginStationCode,
		arg.TerminusStationCode,
		arg.OriginSchDepartureMin,
		arg.TotalDistanceKm,
		arg.TotalRuntimeMin,
		arg.RunningDaysBitmap,
		arg.CreatedAt,
	)
	var schedule_id int64
	err := row.Scan(&schedule_id)
	return schedule_id, err
}
