// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries_seed.sql

package db

import (
	"context"
	"database/sql"
)

const generateRunsForDate = `-- name: GenerateRunsForDate :exec
INSERT INTO train_runs (
    run_id,
    schedule_id,
    train_no,
    run_date
)
SELECT
    -- run_id as "<train_no>_<YYYY-MM-DD>"
    printf('%d_%s', ts.train_no, ?1) AS run_id,
    ts.schedule_id,
    ts.train_no,
    ?1
FROM train_schedules ts
JOIN trains t
    ON ts.train_no = t.train_no
WHERE (ts.running_days_bitmap & (1 << ?2)) <> 0
ON CONFLICT (train_no, run_date) DO NOTHING
`

type GenerateRunsForDateParams struct {
	RunDate string      `json:"run_date"`
	Weekday interface{} `json:"weekday"`
}

func (q *Queries) GenerateRunsForDate(ctx context.Context, arg GenerateRunsForDateParams) error {
	_, err := q.db.ExecContext(ctx, generateRunsForDate, arg.RunDate, arg.Weekday)
	return err
}

const upsertStation = `-- name: UpsertStation :exec
INSERT INTO stations (
    station_code,
    station_name,
    zone,
    division,
    address,
    elevation_m,
    lat,
    lng,
    number_of_platforms,
    station_type,
    station_category,
    track_type,
    updated_at
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6,
    ?7,
    ?8,
    ?9,
    ?10,
    ?11,
    ?12,
    CURRENT_TIMESTAMP
)
ON CONFLICT(station_code) DO UPDATE SET
    station_name = excluded.station_name,
    zone = excluded.zone,
    division = excluded.division,
    address = excluded.address,
    elevation_m = excluded.elevation_m,
    lat = excluded.lat,
    lng = excluded.lng,
    number_of_platforms = excluded.number_of_platforms,
    station_type = excluded.station_type,
    station_category = excluded.station_category,
    track_type = excluded.track_type,
    updated_at = CURRENT_TIMESTAMP
`

type UpsertStationParams struct {
	StationCode       string          `json:"station_code"`
	StationName       string          `json:"station_name"`
	Zone              sql.NullString  `json:"zone"`
	Division          sql.NullString  `json:"division"`
	Address           sql.NullString  `json:"address"`
	ElevationM        sql.NullFloat64 `json:"elevation_m"`
	Lat               sql.NullFloat64 `json:"lat"`
	Lng               sql.NullFloat64 `json:"lng"`
	NumberOfPlatforms sql.NullInt64   `json:"number_of_platforms"`
	StationType       sql.NullString  `json:"station_type"`
	StationCategory   sql.NullString  `json:"station_category"`
	TrackType         sql.NullString  `json:"track_type"`
}

func (q *Queries) UpsertStation(ctx context.Context, arg UpsertStationParams) error {
	_, err := q.db.ExecContext(ctx, upsertStation,
		arg.StationCode,
		arg.StationName,
		arg.Zone,
		arg.Division,
		arg.Address,
		arg.ElevationM,
		arg.Lat,
		arg.Lng,
		arg.NumberOfPlatforms,
		arg.StationType,
		arg.StationCategory,
		arg.TrackType,
	)
	return err
}

const upsertTrain = `-- name: UpsertTrain :exec
INSERT INTO trains (
    train_no,
    train_name,
    train_type,
    zone,
    return_train_no,
    coachComposition,
    source_url,
    created_at,
    updated_at
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6,
    ?7,
    COALESCE(?8, CURRENT_TIMESTAMP),
    CURRENT_TIMESTAMP
)
ON CONFLICT(train_no) DO UPDATE SET
    train_name = excluded.train_name,
    train_type = excluded.train_type,
    zone = excluded.zone,
    return_train_no = excluded.return_train_no,
    coachComposition = excluded.coachComposition,
    source_url = excluded.source_url,
    updated_at = CURRENT_TIMESTAMP
`

type UpsertTrainParams struct {
	TrainNo          int64          `json:"train_no"`
	TrainName        string         `json:"train_name"`
	TrainType        string         `json:"train_type"`
	Zone             sql.NullString `json:"zone"`
	ReturnTrainNo    sql.NullInt64  `json:"return_train_no"`
	CoachComposition sql.NullString `json:"coachComposition"`
	SourceUrl        string         `json:"source_url"`
	CreatedAt        interface{}    `json:"created_at"`
}

func (q *Queries) UpsertTrain(ctx context.Context, arg UpsertTrainParams) error {
	_, err := q.db.ExecContext(ctx, upsertTrain,
		arg.TrainNo,
		arg.TrainName,
		arg.TrainType,
		arg.Zone,
		arg.ReturnTrainNo,
		arg.CoachComposition,
		arg.SourceUrl,
		arg.CreatedAt,
	)
	return err
}

const upsertTrainRoute = `-- name: UpsertTrainRoute :exec
INSERT INTO train_routes (
    schedule_id,
    station_code,
    distance_km,
    sch_arrival_min_from_start,
    sch_departure_min_from_start,
    stops
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6
)
ON CONFLICT(schedule_id, station_code) DO UPDATE SET
    distance_km = excluded.distance_km,
    sch_arrival_min_from_start = excluded.sch_arrival_min_from_start,
    sch_departure_min_from_start = excluded.sch_departure_min_from_start,
    stops = excluded.stops
`

type UpsertTrainRouteParams struct {
	ScheduleID               int64   `json:"schedule_id"`
	StationCode              string  `json:"station_code"`
	DistanceKm               float64 `json:"distance_km"`
	SchArrivalMinFromStart   int64   `json:"sch_arrival_min_from_start"`
	SchDepartureMinFromStart int64   `json:"sch_departure_min_from_start"`
	Stops                    int64   `json:"stops"`
}

func (q *Queries) UpsertTrainRoute(ctx context.Context, arg UpsertTrainRouteParams) error {
	_, err := q.db.ExecContext(ctx, upsertTrainRoute,
		arg.ScheduleID,
		arg.StationCode,
		arg.DistanceKm,
		arg.SchArrivalMinFromStart,
		arg.SchDepartureMinFromStart,
		arg.Stops,
	)
	return err
}

const upsertTrainRun = `-- name: UpsertTrainRun :exec
INSERT INTO train_runs (
    run_id,
    schedule_id,
    train_no,
    run_date,
    created_at,
    updated_at
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP
)
ON CONFLICT(run_id) DO UPDATE SET
    schedule_id = excluded.schedule_id,
    updated_at = CURRENT_TIMESTAMP
`

type UpsertTrainRunParams struct {
	RunID      string `json:"run_id"`
	ScheduleID int64  `json:"schedule_id"`
	TrainNo    int64  `json:"train_no"`
	RunDate    string `json:"run_date"`
}

func (q *Queries) UpsertTrainRun(ctx context.Context, arg UpsertTrainRunParams) error {
	_, err := q.db.ExecContext(ctx, upsertTrainRun,
		arg.RunID,
		arg.ScheduleID,
		arg.TrainNo,
		arg.RunDate,
	)
	return err
}

const upsertTrainSchedule = `-- name: UpsertTrainSchedule :one
INSERT INTO train_schedules (
    train_no,
    origin_station_code,
    terminus_station_code,
    origin_sch_departure_min,
    total_distance_km,
    total_runtime_min,
    running_days_bitmap,
    created_at,
    updated_at
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6,
    ?7,
    COALESCE(?8, CURRENT_TIMESTAMP),
    CURRENT_TIMESTAMP
)
ON CONFLICT(
    train_no,
    origin_station_code,
    terminus_station_code,
    origin_sch_departure_min
) DO UPDATE SET
    total_distance_km = excluded.total_distance_km,
    total_runtime_min = excluded.total_runtime_min,
    running_days_bitmap = excluded.running_days_bitmap,
    updated_at = CURRENT_TIMESTAMP
RETURNING schedule_id
`

type UpsertTrainScheduleParams struct {
	TrainNo               int64       `json:"train_no"`
	OriginStationCode     string      `json:"origin_station_code"`
	TerminusStationCode   string      `json:"terminus_station_code"`
	OriginSchDepartureMin int64       `json:"origin_sch_departure_min"`
	TotalDistanceKm       float64     `json:"total_distance_km"`
	TotalRuntimeMin       int64       `json:"total_runtime_min"`
	RunningDaysBitmap     int64       `json:"running_days_bitmap"`
	CreatedAt             interface{} `json:"created_at"`
}

func (q *Queries) UpsertTrainSchedule(ctx context.Context, arg UpsertTrainScheduleParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, upsertTrainSchedule,
		arg.TrainNo,
		arg.OriginStationCode,
		arg.TerminusStationCode,
		arg.OriginSchDepartureMin,
		arg.TotalDistanceKm,
		arg.TotalRuntimeMin,
		arg.RunningDaysBitmap,
		arg.CreatedAt,
	)
	var schedule_id int64
	err := row.Scan(&schedule_id)
	return schedule_id, err
}
